# chaimaker.py
import logging
from operator import *

from scope.chaivars import *
from scope.chaiflow import *
from scope.chaigen import *


class ChaiMaker():
    """
    Generates assembly code based on parse tree generated by parser.
        parse_tree - tree generated by SLY
    """

    def __init__(self, parse_tree):
        # Declares dict of global variables
        self.tree = parse_tree
        self.global_vars = {}
        self.var_index = {}
        self.next_free_mem_index = 0

        self.code = []
        self.program_counter = 0

    def alloc_global_vars(self, header):
        """
        Translates declarations given in program header into dict of global variables
        :param header: header structure
        :return: self
        """
        if header:
            for variable in header:
                if isinstance(variable, Variable):
                    pid = variable.pidentifier

                    if not pid in self.global_vars.keys():
                        self.global_vars[pid] = variable
                        self.var_index[pid] = self.next_free_mem_index

                        if isinstance(variable, Int):
                            self.next_free_mem_index += 1
                        elif isinstance(variable, IntArray):
                            self.next_free_mem_index += variable.length
                    else:
                        raise Exception("Variable with pidentifier {} already declared".format(pid))
        else:
            logging.debug("Empty header given, no declarations")

    def get_mem_index(self, variable):
        """
        Returns the memory index of variable
        :param variable:
        :return: memory index
        """
        pid = variable.pidentifier
        return self.get_mem_index_for_pid(pid)

    def get_mem_index_for_pid(self, pid):
        """
        Returns the memory index of given pidentifier
        :param pid: pidentifier
        :return:
        """
        if pid in self.var_index.keys():
            return self.var_index[pid]
        else:
            raise Exception("Variable with pidentifier {} was not declared before use".format(pid))

    def get_object_from_mem(self, pidentifier):
        """
        Returns object for given pidentifier from memory
        :param pidentifier:
        :return:
        """
        if pidentifier in self.global_vars.keys():
            return self.global_vars[pidentifier]
        else:
            raise Exception("Variable with pidentifier {} was not declared".format(pidentifier))

    def is_updated_after_comp(self, variable):
        """
        Returns whether variable was determined to be updated after compilation
        :param variable:
        :return: True if yes, False if no
        """
        if variable.pidentifier in self.global_vars.keys():
            logging.debug("Variable with pidentifier {} status of updating after comp {}".format(
                variable.pidentifier, self.global_vars[variable.pidentifier].updated_after_compilation))
            return self.global_vars[variable.pidentifier].updated_after_compilation
        else:
            raise Exception("Variable with pidentifier {} was not declared".format(variable.pidentifier))

    def is_declared(self, variable):
        """
        Returns whether given variable was declared in global_vars
        :param variable:
        :return: True if yes, False if no
        """
        if variable.pidentifier in self.global_vars.keys():
            return True
        else:
            return False

    def is_array_index_in_bounds(self, array, index):
        """
        Checks whether given element index is inside array's bounds
        :param array:
        :param index:
        :return:
        """
        if index < array.from_val or index > array.to_val:
            return False
        else:
            return True

    def get_value_of_assignee(self, assignee):
        """
        Returns the value of assignee, whether it is an integer, or other variable
        (which value is not changing after compilation)
        :param assignee:
        :return:
        """
        if isinstance(assignee, Int):
            # If we're assigning variable to variable, get the value of asignee
            npid = assignee.pidentifier

            if self.global_vars[npid].updated_after_comp:
                raise Exception("Cannot obtain the value because it will be updated after compilation")
            else:
                if npid in self.global_vars.keys():
                    value = self.global_vars[npid].value
                    # logging.debug("Assigning {} := {} := {}".format(pid, npid, value))

                    if value is None:
                        raise Exception("Accessing contents of variable {} before declaration".format(npid))
                    else:
                        return value
                else:
                    raise Exception("Variable {} was not declared".format(npid))
        elif isinstance(assignee, str):
            # If we're assigning number to variable, get it
            value = int(assignee)
            # logging.debug("Assigning {} := {}".format(pid, value))
            return value

    def set_value_of_assignee(self, assignee, value):
        """
        Stores the new computed value of assignee at compilation-time
        :param value:
        :param assignee:
        :return:
        """
        if assignee.pidentifier in self.global_vars.keys():
            if not self.global_vars[assignee.pidentifier].updated_after_compilation:
                self.global_vars[assignee.pidentifier].value = value
            else:
                raise Exception("Value of {} is updating after compilation, cannot compute it on compilation".format(
                    assignee.pidentifier))
        else:
            raise Exception("Variable {} was not declared".format(assignee.pidentifier))

    def handle_assignment(self, assignment):
        """
        Delegates assignment to proper method
        :param assignment:
        :return:
        """
        variable = assignment.identifier

        if isinstance(variable, Int):
            return self.handle_var_assignment(assignment)
        elif isinstance(variable, IntArrayElement):
            return self.handle_arrayvar_assignment(assignment)
        else:
            raise Exception("Invalid assignment to pidentifier: {}".format(variable.pidentifier))

    def handle_arrayvar_assignment(self, assignment):
        """
        Handles the assignment of array element to value or expression.
        More spaghetti-code!
        :param assignment:
        :return:
        """
        variable = assignment.identifier
        expression = assignment.expression.return_expression()

        logging.debug("Handling assignment of {} to expression: {}".format(variable, expression))

        # Get array we want to access
        array_pid = variable.array_pid
        array = self.get_object_from_mem(array_pid)
        logging.debug("Getting array {}: {}".format(array_pid, array))

        # Get the object representing the element of array we want to access
        element = variable.element

        # Get details about array
        var_array_element_index = self.get_value_of_assignee(element)
        var_array_index_in_mem = self.get_mem_index(array)
        var_array_offset = array.offset
        var_array_length = array.length

        if isinstance(element, str) or (isinstance(element, Int) and not self.is_updated_after_comp(element)):
            # If we know the array index we want to assign to
            # (we know that array(var) converts to something like array(16))

            # Calculate the absolute index of array element in memory
            index = var_array_element_index - var_array_offset + var_array_index_in_mem + 1

            # Assign new value to the calculated index
            # Note: pid is not used here, though needs to be passed (?)
            return self.handle_index_expression_assignment(expression, index, pid=array_pid, is_storing_values=False)

        elif isinstance(element, Int) and self.is_updated_after_comp(element):
            # If we don't know the array index we want to assign to
            # We don't know what's the value of var in array(var)

            # Get the index of variable in memory
            variable_mem_index = self.get_mem_index(element)

            if len(expression) == 1:
                assignee = expression[0]

                if isinstance(assignee, str) or (isinstance(assignee, Int) and not self.is_updated_after_comp(
                        assignee)):
                    # If we assign array(var) := constant
                    value = self.get_value_of_assignee(assignee)
                    return gen_assign_array_var_const(const_value=value, var_mem_index=variable_mem_index,
                                                      array_mem_index=var_array_index_in_mem,
                                                      array_offset=var_array_offset)
                elif isinstance(assignee, Int) and self.is_updated_after_comp(assignee):
                    # If we assign array(var) := another_variable
                    var_index = self.get_mem_index(assignee)
                    return gen_assign_array_var_var(to_var_index=var_index, var_mem_index=variable_mem_index,
                                                    array_mem_index=var_array_index_in_mem,
                                                    array_offset=var_array_offset)

                elif isinstance(assignee, IntArrayElement):
                    # If we assign array(var) := another_array(another_var)
                    # Get value from anpther_array at given index
                    contents = assignee.element

                    to_array_pid = assignee.array_pid
                    to_array_object = self.get_object_from_mem(to_array_pid)

                    to_array_mem_index, to_array_offset = self.get_mem_index_for_pid(to_array_pid), \
                                                          to_array_object.offset

                    if isinstance(contents, str) or (isinstance(contents, Int) and not self.is_updated_after_comp()):
                        # If we assign array(var) := another_array(index) and we know index
                        index_of_another_array = self.get_value_of_assignee(contents)

                        return gen_assign_array_var_array_var(to_array_offset=to_array_offset,
                                                              to_array_mem_index=to_array_mem_index,
                                                              to_var_vid=index_of_another_array,
                                                              from_var_mem_index=variable_mem_index,
                                                              from_array_mem_index=var_array_index_in_mem,
                                                              from_array_offset=var_array_offset)

                    elif isinstance(contents, Int) and self.is_updated_after_comp(contents):
                        mem_index_of_index = self.get_mem_index(contents)

                        return gen_assign_array_var_array_var(to_array_offset=to_array_offset,
                                                              to_array_mem_index=to_array_mem_index,
                                                              to_var_vid=mem_index_of_index,
                                                              from_var_mem_index=variable_mem_index,
                                                              from_array_mem_index=var_array_index_in_mem,
                                                              from_array_offset=var_array_offset)

            elif len(expression) == 3:
                # Perform numerical operation (+, -, *, /, %) assignment
                # array(var) := a OPERAND b
                a, operand, b = expression

                if (isinstance(a, str) and isinstance(b, str)) \
                        or (isinstance(a, str) and isinstance(b, Int) and self.is_updated_after_comp(b) == False) \
                        or (isinstance(a, Int) and self.is_updated_after_comp(a) == False and isinstance(b, str) \
                            or (isinstance(a, Int) and self.is_updated_after_comp(a) == False and isinstance(b, Int) \
                                and self.is_updated_after_comp(b) == False)):

                    # If we know values of a and b at compilation time
                    a_val = self.get_value_of_assignee(a)
                    b_val = self.get_value_of_assignee(b)

                    # Count the value of assignment
                    value = operand(a_val, b_val)
                    # logging.debug("Computed {} := {}".format(pid, value))

                    # Update the value for x: stored in global dict
                    # if is_storing_values:
                    #     self.global_vars[pid].value = value
                    # self.set_value_of_assignee(variable, value)

                    # Generate code for value assignment
                    return gen_assign_array_var_const(const_value=value, var_mem_index=var_array_element_index,
                                                      array_mem_index=var_array_index_in_mem,
                                                      array_offset=var_array_offset)
                else:
                    # Handle case when we don't know the variable's value at compilation time
                    # a_vid = None
                    # b_vid = None
                    # a_const = None
                    # b_const = None
                    a_array = None
                    b_array = None
                    a_array_mem_index = 0
                    b_array_mem_index = 0
                    a_array_offset = 0
                    b_array_offset = 0

                    if isinstance(a, str):
                        a_vid = self.get_value_of_assignee(a)
                        a_const = True

                    if isinstance(a, Int) and self.is_updated_after_comp(a):
                        a_vid = self.get_mem_index(a)
                        a_const = False

                    if isinstance(a, IntArrayElement):
                        # Get value from array at given index
                        a_contents = a.element
                        a_array_pid = a.array_pid
                        a_array_object = self.get_object_from_mem(a_array_pid)
                        a_array_mem_index = self.get_mem_index_for_pid(a_array_pid)
                        a_array_offset = a_array_object.offset

                        if isinstance(a_contents, str):
                            # If we're given an integer, read the value of array at index
                            a_vid = self.get_value_of_assignee(a_contents) + a_array_mem_index - a_array_offset + 1

                            # Set to false because we need to load value from mem index given above
                            a_const = False

                        elif isinstance(a_contents, Int):
                            a_const = False

                            if not self.is_updated_after_comp(a_contents):
                                a_vid = self.get_value_of_assignee(a_contents) + a_array_mem_index - a_array_offset + 1
                                a_array = True
                            else:
                                # Handle case where we have to get the value of var in array(var) from assembly
                                a_vid = self.get_mem_index(a_contents) - a_array_offset
                                a_array = True

                    if isinstance(b, str):
                        b_vid = self.get_value_of_assignee(b)
                        b_const = True

                    if isinstance(b, Int) and self.is_updated_after_comp(b):
                        b_vid = self.get_mem_index(b)
                        b_const = False

                    if isinstance(b, IntArrayElement):
                        # Get value from array at given index
                        b_contents = b.element
                        b_array_pid = b.array_pid
                        b_array_object = self.get_object_from_mem(b_array_pid)
                        b_array_mem_index = self.get_mem_index_for_pid(b_array_pid)
                        b_array_offset = b_array_object.offset

                        if isinstance(b_contents, str):
                            # If we're given an integer, read the value of array at index
                            b_vid = self.get_value_of_assignee(b_contents) + b_array_mem_index - b_array_offset + 1
                            # Set to false because we need to load value from mem index given above
                            b_const = False

                        elif isinstance(b_contents, Int):
                            b_const = False

                            if not self.is_updated_after_comp(b_contents):
                                b_vid = self.get_value_of_assignee(b_contents) + b_array_mem_index - b_array_offset + 1
                                b_array = True
                            else:
                                # Handle case where we have to get the value of var in array(var) from assembly
                                b_vid = self.get_mem_index(b_contents) - b_array_offset + 1
                                b_array = True

                    logging.debug("is_a_array: {}, is_b_array: {}".format(a_array, b_array))

                    return gen_assign_array_var_to_expr(var_mem_index=var_array_element_index,
                                                        array_mem_index=var_array_index_in_mem,
                                                        array_offset=var_array_offset,
                                                        a_vid=a_vid, b_vid=b_vid, a_const=a_const,
                                                        b_const=b_const, a_array=a_array, a_array_offset=a_array_offset,
                                                        a_array_mem_index=a_array_mem_index, b_array=b_array,
                                                        b_array_offset=b_array_offset,
                                                        b_array_mem_index=b_array_mem_index,
                                                        operand=operand, pc_val=self.program_counter)

    def handle_var_assignment(self, assignment):
        """
        Handles the assignment of values.
        :param assignment: assignment representation
        :return:
        """
        variable = assignment.identifier
        expression = assignment.expression.return_expression()
        pid = variable.pidentifier
        index = self.get_mem_index(variable)
        return self.handle_index_expression_assignment(expression, index, pid, is_storing_values=True)

    def handle_index_expression_assignment(self, expression, index, pid, is_storing_values):
        """
        Stores the value of an expression at given index.
        :return:
        """
        if len(expression) == 1:
            # Handle assignments
            # a := b or a := number
            assignee = expression[0]
            logging.debug("Assign {} := {}".format(pid, assignee))

            if isinstance(assignee, str) or (isinstance(assignee, Int) and not self.is_updated_after_comp(assignee)):
                # If assigning a: = value known at compilation time
                value = self.get_value_of_assignee(assignee)
                if is_storing_values:
                    self.global_vars[pid].value = value  # Update value in global dict

                logging.debug("Assignee is string or integer we know at compilation time")
                return gen_assign_var_to_const(index, value)

            elif isinstance(assignee, Int) and self.is_updated_after_comp(assignee):
                # We don't know the variable's value at compilation time, so we have to do this old-school way
                # We have to handle a := b
                b_index = self.get_mem_index(assignee)

                logging.debug("Assignee is an integer we don't know at compilation time")
                return gen_assign_var_to_var(index, b_index)

            elif isinstance(assignee, IntArrayElement):
                # Get value from array at given index
                contents = assignee.element

                array_pid = assignee.array_pid
                array_object = self.get_object_from_mem(array_pid)

                array_mem_index = self.get_mem_index(array_object)
                array_offset = array_object.offset

                # Make sure that the assignee is marked as updated after compilation
                self.global_vars[pid].updated_after_compilation = True

                if isinstance(contents, str):
                    # If we're given an integer
                    # +1 here because of row containing the offset

                    logging.debug("Contents is determined to be: {}".format(contents))

                    contents_vid = self.get_value_of_assignee(contents)
                    element_const = True

                    logging.debug("Assignee has index {} in array".format(contents_vid))

                elif isinstance(contents, Int):
                    if self.is_updated_after_comp(contents):
                        contents_vid = self.get_mem_index(contents)
                        element_const = False

                        logging.debug("Assignee updated after compilation")
                    else:
                        contents_vid = self.get_value_of_assignee(contents)
                        element_const = True

                        logging.debug("Assignee value known at compilation")

                return gen_assign_var_to_array_el(var_index=index, array_mem_index=array_mem_index,
                                                  element_vid=contents_vid,
                                                  element_const=element_const,
                                                  array_offset=array_offset)

        elif len(expression) == 3:
            # Perform numerical operation (+, -, *, /, %) assignment (x := a + b)
            a, operand, b = expression

            if (isinstance(a, str) and isinstance(b, str)) \
                    or (isinstance(a, str) and isinstance(b, Int) and self.is_updated_after_comp(b) == False) \
                    or (isinstance(a, Int) and self.is_updated_after_comp(a) == False and isinstance(b, str) \
                        or (isinstance(a, Int) and self.is_updated_after_comp(a) == False and isinstance(b, Int) \
                            and self.is_updated_after_comp(b) == False)):

                # Values of a and b are both known at compilation time
                # Get numerical values of a, b
                a_val = self.get_value_of_assignee(a)
                b_val = self.get_value_of_assignee(b)

                # Count the value of assignment
                value = operand(a_val, b_val)
                logging.debug("Computed {} := {}".format(pid, value))

                # Update the value for x: stored in global dict
                if is_storing_values:
                    self.global_vars[pid].value = value
                    # self.set_value_of_assignee(variable, value)

                # Generate code for value assignment
                return gen_assign_var_to_const(index, value)
            else:
                # Handle case when we don't know the variable's value at compilation time
                # a_vid = None
                # b_vid = None
                # a_const = None
                # b_const = None
                a_array = None
                b_array = None
                a_array_mem_index = 0
                b_array_mem_index = 0
                a_array_offset = 0
                b_array_offset = 0

                if isinstance(a, str):
                    a_vid = self.get_value_of_assignee(a)
                    a_const = True

                if isinstance(a, Int) and self.is_updated_after_comp(a):
                    a_vid = self.get_mem_index(a)
                    a_const = False

                if isinstance(a, IntArrayElement):
                    # Get value from array at given index
                    a_contents = a.element
                    a_array_pid = a.array_pid
                    a_array_object = self.get_object_from_mem(a_array_pid)
                    a_array_mem_index = self.get_mem_index_for_pid(a_array_pid)
                    a_array_offset = a_array_object.offset

                    if isinstance(a_contents, str):
                        # If we're given an integer, read the value of array at index
                        a_vid = self.get_value_of_assignee(a_contents) + a_array_mem_index - a_array_offset + 1

                        # Set to false because we need to load value from mem index given above
                        a_const = False

                    elif isinstance(a_contents, Int):
                        a_const = False

                        if not self.is_updated_after_comp(a_contents):
                            a_vid = self.get_value_of_assignee(a_contents) + a_array_mem_index - a_array_offset + 1
                            a_array = True
                        else:
                            # Handle case where we have to get the value of var in array(var) from assembly
                            a_vid = self.get_mem_index(a_contents) - a_array_offset
                            a_array = True

                if isinstance(b, str):
                    b_vid = self.get_value_of_assignee(b)
                    b_const = True

                if isinstance(b, Int) and self.is_updated_after_comp(b):
                    b_vid = self.get_mem_index(b)
                    b_const = False

                if isinstance(b, IntArrayElement):
                    # Get value from array at given index
                    b_contents = b.element
                    b_array_pid = b.array_pid
                    b_array_object = self.get_object_from_mem(b_array_pid)
                    b_array_mem_index = self.get_mem_index_for_pid(b_array_pid)
                    b_array_offset = b_array_object.offset

                    if isinstance(b_contents, str):
                        # If we're given an integer, read the value of array at index
                        b_vid = self.get_value_of_assignee(b_contents) + b_array_mem_index - b_array_offset + 1
                        # Set to false because we need to load value from mem index given above
                        b_const = False


                    elif isinstance(b_contents, Int):
                        b_const = False

                        if not self.is_updated_after_comp(b_contents):
                            b_vid = self.get_value_of_assignee(b_contents) + b_array_mem_index - b_array_offset + 1
                            b_array = True
                        else:
                            # Handle case where we have to get the value of var in array(var) from assembly
                            b_vid = self.get_mem_index(b_contents) - b_array_offset + 1
                            b_array = True

                logging.debug("WE'RE DOING THIS is_a_array: {}, is_b_array: {}".format(a_array, b_array))

                return gen_assign_var_to_expr(assign_to_var_index=index, a_vid=a_vid, b_vid=b_vid, a_const=a_const,
                                              b_const=b_const, a_array=a_array, a_array_offset=a_array_offset,
                                              a_array_mem_index=a_array_mem_index, b_array=b_array,
                                              b_array_offset=b_array_offset, b_array_mem_index=b_array_mem_index,
                                              operand=operand, pc_val=self.program_counter)

    def handle_read(self, read_statement):
        variable = read_statement.to_variable

        # Check if variable was declared
        if self.is_declared(variable):
            # Note that variable will be updated after compilation

            if isinstance(variable, Int):
                # Mark variable value as unknown during compilation
                self.global_vars[variable].updated_after_compilation = True

                # Get memory index assigned for variable
                index = self.get_mem_index(variable)
                return gen_read_to_var(var_index=index)

            elif isinstance(variable, IntArrayElement):
                array = self.get_object_from_mem(variable.array_pid)

                if isinstance(variable.element, str) or (isinstance(variable.element, Int) and not
                                                         self.is_updated_after_comp(variable.element)):
                    # If index to which to read is known
                    index = self.get_value_of_assignee(variable.element)

                    if self.is_array_index_in_bounds(array=array, index=index):
                        index += self.get_mem_index(array) + 1 - array.offset
                        return gen_read_to_var(var_index=index)
                    else:
                        raise Exception("Array index {} out of declared bounds: ({}, {}".format(index,
                                                                                            array.from_val,
                                                                                            array.to_val))

                elif isinstance(variable.element, Int) and self.is_updated_after_comp(variable.element):
                    # Get memory index of array index's value
                    address_index = self.get_mem_index(variable.element)

                    return gen_read_to_array_var(address_index=address_index, array_index=self.get_mem_index(array),
                                                 array_offset=array.offset)
                else:
                    raise Exception("Invalid variable type assignment during read operation for pidentifier {}".format(variable))
        else:
            raise Exception("Variable {} assignment during READ operation before declaration".format(variable))

    def handle_write(self, statement):
        """
        Handles translation of WRITE function call in code into assembly code.
        :param statement:
        :return: assembly code
        """
        from_var = statement.from_variable

        if isinstance(from_var, str):
            # If we're given a number
            value = self.get_value_of_assignee(from_var)
            return gen_write_const(value)

        elif isinstance(from_var, Int):
            # If we're given a variable to print
            pid = from_var.pidentifier
            index = self.get_mem_index(from_var)

            if self.is_updated_after_comp(from_var):
                return gen_write_var(index)
            else:
                # Get the value of var and handle it as constant
                value = self.get_value_of_assignee(from_var)
                return gen_write_const(value)

        elif isinstance(from_var, IntArrayElement):
            index_var = from_var.element
            var_array = self.get_object_from_mem(from_var.array_pid)

            if isinstance(index_var, str) or isinstance(index_var, Int) and not self.is_updated_after_comp(index_var):
                # Get the array index that we want to access
                index_value = self.get_value_of_assignee(index_var)

                # Calculate the index in memory of array(index_value)
                absolute_mem_index = index_value - var_array.offset + self.get_mem_index(var_array) + 1

                return gen_write_var(absolute_mem_index)

            elif isinstance(index_var, Int) and self.is_updated_after_comp(index_var):
                # Get the location in memory of the variable
                index_adress = self.get_mem_index(index_var)

                return gen_write_array_var(var_index=index_adress, array_index=self.get_mem_index(var_array),
                                           array_offset=var_array.offset)

    def handle_if_statement(self, statement):
        """
        Handles translation of if statement into assembly code
        :param statement:
        :return:
        """

        a, operand, b = statement.condition.return_condition()
        commands = statement.commands
        code = []

        logging.debug("Handle if statement for condition: ({} {} {}), commands: {}".format(a, operand, b, commands))

        jump_count = None

        a_pid, b_pid = a.pidentifier, b.pidentifier
        a_val, b_val = self.get_value_of_assignee(a), self.get_value_of_assignee(b)

        # Handle conditions
        if operand == operator.gt:
            # if (a > b) -> if (a - b) > 0 -> JZERO

            # Store value of a in B registry, b in C registry
            code += gen_getval(var_mem_index=self.var_index[a_pid], to_registry='B')
            code += gen_getval(var_mem_index=self.var_index[b_pid], to_registry='C')

            # Perform subtraction (a - b)
            code.append('SUB B C')
            code.append('JZERO B {}'.format(jump_count))

    def translate_commands(self, commands):
        """
        Translates given commands into assembly code
        :param commands: list of commands
        :return: assembly code
        """
        code = []

        # NOTE: It might be beneficial to use code.append() (and store lists of generated code for each output)?

        for command in commands:
            if isinstance(command, Assign):
                translated_code = self.handle_assignment(command)

            elif isinstance(command, Write):
                translated_code = self.handle_write(command)

            elif isinstance(command, Read):
                translated_code = self.handle_read(command)

            elif isinstance(command, If):
                translated_code = self.handle_if_statement(command)

            self.program_counter += len(translated_code)
            code.extend(translated_code)

        return code

    def make(self):
        """
        Goes through generated tree and calls method responsible for given blocks' translations.
        :return: self
        """
        # print("Code tree: {}".format(self.tree))

        logging.basicConfig(level=logging.DEBUG)

        # Divide the program into header (declarations) and code
        header = self.tree[0]
        body = self.tree[1]

        logging.debug("Code header: {}".format(header))
        logging.debug("Code body: {}".format(body))

        self.alloc_global_vars(header)
        logging.debug("Global variables: {}".format(self.global_vars))
        logging.debug("Assigned indexes: {}".format(self.var_index))

        # print("Identifier: {}".format(body[0].identifier))
        # print("Expression value: {}".format(body[0].expression.return_expression()))
        # print("Expression array element: {}".format(body[0].expression.return_expression()[0].element))

        output = self.translate_commands(body)
        output.append('HALT')

        print(output)

        outf = open('tests/program3.out', 'w').write('\n'.join(output))

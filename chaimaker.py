# chaimaker.py
import logging
from operator import *

from scope.chaivars import *
from scope.chaiflow import *
from scope.chaigen import *


class ChaiMaker():
    """
    Generates assembly code based on parse tree generated by parser.
        parse_tree - tree generated by SLY
    """

    def __init__(self, parse_tree):
        # Declares dict of global variables
        self.tree = parse_tree
        self.global_vars = {}
        self.var_index = {}
        self.next_free_mem_index = 0

        self.code = []
        self.program_counter = 0

    def alloc_global_vars(self, header):
        """
        Translates declarations given in program header into dict of global variables
        :param header: header structure
        :return: self
        """
        if header:
            for variable in header:
                if isinstance(variable, Variable):
                    pid = variable.pidentifier

                    if not pid in self.global_vars.keys():
                        self.global_vars[pid] = variable
                        self.var_index[pid] = self.next_free_mem_index

                        if isinstance(variable, Int):
                            self.next_free_mem_index += 1
                        elif isinstance(variable, IntArray):
                            self.next_free_mem_index += variable.length
                    else:
                        raise Exception("Variable with pidentifier {} already declared".format(pid))
        else:
            logging.debug("Empty header given, no declarations")

    def get_mem_index(self, variable):
        """
        Returns the memory index of variable
        :param variable:
        :return: memory index
        """
        pid = variable.pidentifier
        return self.get_mem_index_for_pid(pid)

    def get_mem_index_for_pid(self, pid):
        """
        Returns the memory index of given pidentifier
        :param pid: pidentifier
        :return:
        """
        if pid in self.var_index.keys():
            return self.var_index[pid]
        else:
            raise Exception("Variable with pidentifier {} was not declared before use".format(pid))

    def get_object_from_mem(self, pidentifier):
        """
        Returns object for given pidentifier from memory
        :param pidentifier:
        :return:
        """
        if pidentifier in self.global_vars.keys():
            return self.global_vars[pidentifier]
        else:
            raise Exception("Variable with pidentifier {} was not declared".format(pidentifier))

    def is_updated_after_comp(self, variable):
        """
        Returns whether variable was determined to be updated after compilation
        :param variable:
        :return: True if yes, False if no
        """
        if variable.pidentifier in self.global_vars.keys():
            logging.debug("Variable with pidentifier {} status of updating after comp {}".format(
                variable.pidentifier, self.global_vars[variable.pidentifier].updated_after_compilation))
            return self.global_vars[variable.pidentifier].updated_after_compilation
        else:
            raise Exception("Variable with pidentifier {} was not declared".format(variable.pidentifier))

    def is_declared(self, variable):
        """
        Returns whether given variable was declared in global_vars
        :param variable:
        :return: True if yes, False if no
        """
        if variable.pidentifier in self.global_vars.keys():
            return True
        else:
            return False

    def is_array_index_in_bounds(self, array, index):
        """
        Checks whether given element index is inside array's bounds
        :param array:
        :param index:
        :return:
        """
        if index < array.from_val or index > array.to_val:
            return False
        else:
            return True

    def get_value_of_assignee(self, assignee):
        """
        Returns the value of assignee, whether it is an integer, or other variable
        (which value is not changing after compilation)
        :param assignee:
        :return:
        """
        if isinstance(assignee, Int):
            # If we're assigning variable to variable, get the value of asignee
            npid = assignee.pidentifier

            logging.debug("Assignee: {} pid: {}".format(assignee, npid))

            if self.is_updated_after_comp(assignee):
                raise Exception("Cannot obtain the value because it will be updated after compilation")
            else:
                if npid in self.global_vars.keys():
                    value = self.global_vars[npid].value
                    # logging.debug("Assigning {} := {} := {}".format(pid, npid, value))

                    if value is None:
                        raise Exception("Accessing contents of variable {} before declaration".format(npid))
                    else:
                        return value
                else:
                    raise Exception("Variable {} was not declared".format(npid))
        elif isinstance(assignee, str):
            # If we're assigning number to variable, get it
            value = int(assignee)
            # logging.debug("Assigning {} := {}".format(pid, value))
            return value

    def set_value_of_assignee(self, assignee, value):
        """
        Stores the new computed value of assignee at compilation-time
        :param value:
        :param assignee:
        :return:
        """
        if assignee.pidentifier in self.global_vars.keys():
            if not self.global_vars[assignee.pidentifier].updated_after_compilation:
                self.global_vars[assignee.pidentifier].value = value
            else:
                raise Exception("Value of {} is updating after compilation, cannot compute it on compilation".format(
                    assignee.pidentifier))
        else:
            raise Exception("Variable {} was not declared".format(assignee.pidentifier))

    def handle_assignment(self, assignment):
        """
        Delegates assignment to proper method
        :param assignment:
        :return:
        """
        variable = assignment.identifier

        if isinstance(variable, Int):
            return self.handle_var_assignment(assignment)
        elif isinstance(variable, IntArrayElement):
            return self.handle_arrayvar_assignment(assignment)
        else:
            raise Exception("Invalid assignment to pidentifier: {}".format(variable.pidentifier))

    def handle_arrayvar_assignment(self, assignment):
        """
        Handles the assignment of array element to value or expression.
        More spaghetti-code!
        :param assignment:
        :return:
        """
        variable = assignment.identifier
        expression = assignment.expression.return_expression()

        logging.debug("Handling assignment of {} to expression: {}".format(variable, expression))

        # Get array we want to access
        array_pid = variable.array_pid
        array = self.get_object_from_mem(array_pid)
        logging.debug("Getting array {}: {}".format(array_pid, array))

        # Get the object representing the element of array we want to access
        element = variable.element

        # Get details about array
        var_array_element_index = self.get_value_of_assignee(element)
        var_array_index_in_mem = self.get_mem_index(array)
        var_array_offset = array.offset
        var_array_length = array.length

        if isinstance(element, str) or (isinstance(element, Int) and not self.is_updated_after_comp(element)):
            # If we know the array index we want to assign to
            # (we know that array(var) converts to something like array(16))

            # Calculate the absolute index of array element in memory
            index = var_array_element_index - var_array_offset + var_array_index_in_mem + 1

            # Assign new value to the calculated index
            # Note: pid is not used here, though needs to be passed (?)
            return self.handle_index_expression_assignment(expression, index, pid=array_pid, is_storing_values=False)

        elif isinstance(element, Int) and self.is_updated_after_comp(element):
            # If we don't know the array index we want to assign to
            # We don't know what's the value of var in array(var)

            # Get the index of variable in memory
            variable_mem_index = self.get_mem_index(element)

            if len(expression) == 1:
                assignee = expression[0]

                if isinstance(assignee, str) or (isinstance(assignee, Int) and not self.is_updated_after_comp(
                        assignee)):
                    # If we assign array(var) := constant
                    value = self.get_value_of_assignee(assignee)
                    return gen_assign_array_var_const(const_value=value, var_mem_index=variable_mem_index,
                                                      array_mem_index=var_array_index_in_mem,
                                                      array_offset=var_array_offset)
                elif isinstance(assignee, Int) and self.is_updated_after_comp(assignee):
                    # If we assign array(var) := another_variable
                    var_index = self.get_mem_index(assignee)
                    return gen_assign_array_var_var(to_var_index=var_index, var_mem_index=variable_mem_index,
                                                    array_mem_index=var_array_index_in_mem,
                                                    array_offset=var_array_offset)

                elif isinstance(assignee, IntArrayElement):
                    # If we assign array(var) := another_array(another_var)
                    # Get value from anpther_array at given index
                    contents = assignee.element

                    to_array_pid = assignee.array_pid
                    to_array_object = self.get_object_from_mem(to_array_pid)

                    to_array_mem_index, to_array_offset = self.get_mem_index_for_pid(to_array_pid), \
                                                          to_array_object.offset

                    if isinstance(contents, str) or (isinstance(contents, Int) and not self.is_updated_after_comp()):
                        # If we assign array(var) := another_array(index) and we know index
                        index_of_another_array = self.get_value_of_assignee(contents)

                        return gen_assign_array_var_array_var(to_array_offset=to_array_offset,
                                                              to_array_mem_index=to_array_mem_index,
                                                              to_var_vid=index_of_another_array,
                                                              from_var_mem_index=variable_mem_index,
                                                              from_array_mem_index=var_array_index_in_mem,
                                                              from_array_offset=var_array_offset)

                    elif isinstance(contents, Int) and self.is_updated_after_comp(contents):
                        mem_index_of_index = self.get_mem_index(contents)

                        return gen_assign_array_var_array_var(to_array_offset=to_array_offset,
                                                              to_array_mem_index=to_array_mem_index,
                                                              to_var_vid=mem_index_of_index,
                                                              from_var_mem_index=variable_mem_index,
                                                              from_array_mem_index=var_array_index_in_mem,
                                                              from_array_offset=var_array_offset)

            elif len(expression) == 3:
                # Perform numerical operation (+, -, *, /, %) assignment
                # array(var) := a OPERAND b
                a, operand, b = expression

                if (isinstance(a, str) and isinstance(b, str)) \
                        or (isinstance(a, str) and isinstance(b, Int) and self.is_updated_after_comp(b) == False) \
                        or (isinstance(a, Int) and self.is_updated_after_comp(a) == False and isinstance(b, str) \
                            or (isinstance(a, Int) and self.is_updated_after_comp(a) == False and isinstance(b, Int) \
                                and self.is_updated_after_comp(b) == False)):

                    # If we know values of a and b at compilation time
                    a_val = self.get_value_of_assignee(a)
                    b_val = self.get_value_of_assignee(b)

                    # Count the value of assignment
                    value = operand(a_val, b_val)
                    # logging.debug("Computed {} := {}".format(pid, value))

                    # Update the value for x: stored in global dict
                    # if is_storing_values:
                    #     self.global_vars[pid].value = value
                    # self.set_value_of_assignee(variable, value)

                    # Generate code for value assignment
                    return gen_assign_array_var_const(const_value=value, var_mem_index=var_array_element_index,
                                                      array_mem_index=var_array_index_in_mem,
                                                      array_offset=var_array_offset)
                else:
                    # Handle case when we don't know the variable's value at compilation time
                    # a_vid = None
                    # b_vid = None
                    # a_const = None
                    # b_const = None
                    a_array = None
                    b_array = None
                    a_array_mem_index = 0
                    b_array_mem_index = 0
                    a_array_offset = 0
                    b_array_offset = 0

                    if isinstance(a, str):
                        a_vid = self.get_value_of_assignee(a)
                        a_const = True

                    if isinstance(a, Int) and self.is_updated_after_comp(a):
                        a_vid = self.get_mem_index(a)
                        a_const = False

                    if isinstance(a, IntArrayElement):
                        # Get value from array at given index
                        a_contents = a.element
                        a_array_pid = a.array_pid
                        a_array_object = self.get_object_from_mem(a_array_pid)
                        a_array_mem_index = self.get_mem_index_for_pid(a_array_pid)
                        a_array_offset = a_array_object.offset

                        if isinstance(a_contents, str):
                            # If we're given an integer, read the value of array at index
                            a_vid = self.get_value_of_assignee(a_contents) + a_array_mem_index - a_array_offset + 1

                            # Set to false because we need to load value from mem index given above
                            a_const = False

                        elif isinstance(a_contents, Int):
                            a_const = False

                            if not self.is_updated_after_comp(a_contents):
                                a_vid = self.get_value_of_assignee(a_contents) + a_array_mem_index - a_array_offset + 1
                                a_array = True
                            else:
                                # Handle case where we have to get the value of var in array(var) from assembly
                                a_vid = self.get_mem_index(a_contents) - a_array_offset
                                a_array = True

                    if isinstance(b, str):
                        b_vid = self.get_value_of_assignee(b)
                        b_const = True

                    if isinstance(b, Int) and self.is_updated_after_comp(b):
                        b_vid = self.get_mem_index(b)
                        b_const = False

                    if isinstance(b, IntArrayElement):
                        # Get value from array at given index
                        b_contents = b.element
                        b_array_pid = b.array_pid
                        b_array_object = self.get_object_from_mem(b_array_pid)
                        b_array_mem_index = self.get_mem_index_for_pid(b_array_pid)
                        b_array_offset = b_array_object.offset

                        if isinstance(b_contents, str):
                            # If we're given an integer, read the value of array at index
                            b_vid = self.get_value_of_assignee(b_contents) + b_array_mem_index - b_array_offset + 1
                            # Set to false because we need to load value from mem index given above
                            b_const = False

                        elif isinstance(b_contents, Int):
                            b_const = False

                            if not self.is_updated_after_comp(b_contents):
                                b_vid = self.get_value_of_assignee(b_contents) + b_array_mem_index - b_array_offset + 1
                                b_array = True
                            else:
                                # Handle case where we have to get the value of var in array(var) from assembly
                                b_vid = self.get_mem_index(b_contents) - b_array_offset + 1
                                b_array = True

                    logging.debug("is_a_array: {}, is_b_array: {}".format(a_array, b_array))

                    return gen_assign_array_var_to_expr(var_mem_index=var_array_element_index,
                                                        array_mem_index=var_array_index_in_mem,
                                                        array_offset=var_array_offset,
                                                        a_vid=a_vid, b_vid=b_vid, a_const=a_const,
                                                        b_const=b_const, a_array=a_array, a_array_offset=a_array_offset,
                                                        a_array_mem_index=a_array_mem_index, b_array=b_array,
                                                        b_array_offset=b_array_offset,
                                                        b_array_mem_index=b_array_mem_index,
                                                        operand=operand, pc_val=self.program_counter)

    def handle_var_assignment(self, assignment):
        """
        Handles the assignment of values.
        :param assignment: assignment representation
        :return:
        """
        variable = assignment.identifier
        expression = assignment.expression.return_expression()
        pid = variable.pidentifier
        index = self.get_mem_index(variable)
        return self.handle_index_expression_assignment(expression, index, pid, is_storing_values=True)

    def handle_index_expression_assignment(self, expression, index, pid, is_storing_values):
        """
        Stores the value of an expression at given index.
        :return:
        """
        if len(expression) == 1:
            # Handle assignments
            # a := b or a := number
            assignee = expression[0]
            logging.debug("Assign {} := {}".format(pid, assignee))

            if isinstance(assignee, str) or (isinstance(assignee, Int) and not self.is_updated_after_comp(assignee)):
                # If assigning a: = value known at compilation time
                value = self.get_value_of_assignee(assignee)
                if is_storing_values:
                    self.global_vars[pid].value = value  # Update value in global dict
                    # self.global_vars[pid].updated_after_compilation = False

                logging.debug("Assignee is string or integer we know at compilation time")
                return gen_assign_var_to_const(index, value)

            elif isinstance(assignee, Int) and self.is_updated_after_comp(assignee):
                # We don't know the variable's value at compilation time, so we have to do this old-school way
                # We have to handle a := b
                b_index = self.get_mem_index(assignee)

                logging.debug("Assignee is an integer we don't know at compilation time")
                return gen_assign_var_to_var(index, b_index)

            elif isinstance(assignee, IntArrayElement):
                # Get value from array at given index
                contents = assignee.element

                array_pid = assignee.array_pid
                array_object = self.get_object_from_mem(array_pid)

                array_mem_index = self.get_mem_index(array_object)
                array_offset = array_object.offset

                # Make sure that the assignee is marked as updated after compilation
                self.global_vars[pid].updated_after_compilation = True

                if isinstance(contents, str):
                    # If we're given an integer
                    # +1 here because of row containing the offset

                    logging.debug("Contents is determined to be: {}".format(contents))

                    contents_vid = self.get_value_of_assignee(contents)
                    element_const = True

                    logging.debug("Assignee has index {} in array".format(contents_vid))

                elif isinstance(contents, Int):
                    if self.is_updated_after_comp(contents):
                        contents_vid = self.get_mem_index(contents)
                        element_const = False

                        logging.debug("Assignee updated after compilation")
                    else:
                        contents_vid = self.get_value_of_assignee(contents)
                        element_const = True

                        logging.debug("Assignee value known at compilation")

                return gen_assign_var_to_array_el(var_index=index, array_mem_index=array_mem_index,
                                                  element_vid=contents_vid,
                                                  element_const=element_const,
                                                  array_offset=array_offset)

        elif len(expression) == 3:
            # Perform numerical operation (+, -, *, /, %) assignment (x := a + b)
            a, operand, b = expression

            if (isinstance(a, str) or (isinstance(a, Int) and not self.is_updated_after_comp(a))) \
                    and (isinstance(b, str) or (isinstance(b, Int) and not self.is_updated_after_comp(b))):

                # Values of a and b are both known at compilation time
                # Get numerical values of a, b
                a_val = self.get_value_of_assignee(a)
                b_val = self.get_value_of_assignee(b)

                # Count the value of assignment
                value = operand(a_val, b_val)
                logging.debug("Computed {} := {}".format(pid, value))

                # Update the value for x: stored in global dict
                if is_storing_values:
                    self.global_vars[pid].value = value
                    # self.set_value_of_assignee(variable, value)

                # Generate code for value assignment
                return gen_assign_var_to_const(index, value)
            else:
                # Handle case when we don't know the variable's value at compilation time
                a_vid = None
                b_vid = None
                a_const = None
                b_const = None
                a_array = None
                b_array = None
                a_array_mem_index = 0
                b_array_mem_index = 0
                a_array_offset = 0
                b_array_offset = 0

                if isinstance(a, str) or (isinstance(a, Int) and not self.is_updated_after_comp(a)):
                    a_vid = self.get_value_of_assignee(a)
                    a_const = True

                if isinstance(a, Int) and self.is_updated_after_comp(a):
                    a_vid = self.get_mem_index(a)
                    a_const = False

                if isinstance(a, IntArrayElement):
                    # Get value from array at given index
                    a_contents = a.element
                    a_array_pid = a.array_pid
                    a_array_object = self.get_object_from_mem(a_array_pid)
                    a_array_mem_index = self.get_mem_index_for_pid(a_array_pid)
                    a_array_offset = a_array_object.offset

                    if isinstance(a_contents, str):
                        # If we're given an integer, read the value of array at index
                        a_vid = self.get_value_of_assignee(a_contents) + a_array_mem_index - a_array_offset + 1

                        # Set to false because we need to load value from mem index given above
                        a_const = False

                    elif isinstance(a_contents, Int):
                        a_const = False

                        if not self.is_updated_after_comp(a_contents):
                            a_vid = self.get_value_of_assignee(a_contents) + a_array_mem_index - a_array_offset + 1
                            a_array = True
                        else:
                            # Handle case where we have to get the value of var in array(var) from assembly
                            a_vid = self.get_mem_index(a_contents) - a_array_offset
                            a_array = True

                if isinstance(b, str) or (isinstance(b, Int) and not self.is_updated_after_comp(b)):
                    b_vid = self.get_value_of_assignee(b)
                    b_const = True
                    logging.debug("b is str : {}".format(b))

                if isinstance(b, Int) and self.is_updated_after_comp(b):
                    b_vid = self.get_mem_index(b)
                    b_const = False
                    logging.debug("b is int : {}".format(b))

                if isinstance(b, IntArrayElement):
                    # Get value from array at given index
                    b_contents = b.element
                    b_array_pid = b.array_pid
                    b_array_object = self.get_object_from_mem(b_array_pid)
                    b_array_mem_index = self.get_mem_index_for_pid(b_array_pid)
                    b_array_offset = b_array_object.offset
                    logging.debug("b is array element : {}".format(b))

                    if isinstance(b_contents, str):
                        # If we're given an integer, read the value of array at index
                        b_vid = self.get_value_of_assignee(b_contents) + b_array_mem_index - b_array_offset + 1
                        # Set to false because we need to load value from mem index given above
                        b_const = False
                        logging.debug("b contents is str : {}".format(b))

                    elif isinstance(b_contents, Int):
                        b_const = False
                        logging.debug("b contents is int : {}".format(b))

                        if not self.is_updated_after_comp(b_contents):
                            b_vid = self.get_value_of_assignee(b_contents) + b_array_mem_index - b_array_offset + 1
                            b_array = True
                            logging.debug("b heree is int : {}".format(b))

                        else:
                            # Handle case where we have to get the value of var in array(var) from assembly
                            b_vid = self.get_mem_index(b_contents) - b_array_offset + 1
                            b_array = True
                            logging.debug("b contherents is int : {}".format(b))

                logging.debug("OUR VALUE B is : {}".format(b))

                logging.debug("WE'RE DOING THIS is_a_array: {}, is_b_array: {}".format(a_array, b_array))

                return gen_assign_var_to_expr(assign_to_var_index=index, a_vid=a_vid, b_vid=b_vid, a_const=a_const,
                                              b_const=b_const, a_array=a_array, a_array_offset=a_array_offset,
                                              a_array_mem_index=a_array_mem_index, b_array=b_array,
                                              b_array_offset=b_array_offset, b_array_mem_index=b_array_mem_index,
                                              operand=operand, pc_val=self.program_counter)

    def handle_read(self, read_statement):
        variable = read_statement.to_variable

        # Check if variable was declared
        if self.is_declared(variable):
            # Note that variable will be updated after compilation

            if isinstance(variable, Int):
                # Mark variable value as unknown during compilation
                self.global_vars[variable.pidentifier].updated_after_compilation = True

                # Get memory index assigned for variable
                index = self.get_mem_index(variable)
                return gen_read_to_var(var_index=index)

            elif isinstance(variable, IntArrayElement):
                array = self.get_object_from_mem(variable.array_pid)

                if isinstance(variable.element, str) or (isinstance(variable.element, Int) and not
                self.is_updated_after_comp(variable.element)):
                    # If index to which to read is known
                    index = self.get_value_of_assignee(variable.element)

                    if self.is_array_index_in_bounds(array=array, index=index):
                        index += self.get_mem_index(array) + 1 - array.offset
                        return gen_read_to_var(var_index=index)
                    else:
                        raise Exception("Array index {} out of declared bounds: ({}, {}".format(index,
                                                                                                array.from_val,
                                                                                                array.to_val))

                elif isinstance(variable.element, Int) and self.is_updated_after_comp(variable.element):
                    # Get memory index of array index's value
                    address_index = self.get_mem_index(variable.element)

                    return gen_read_to_array_var(address_index=address_index, array_index=self.get_mem_index(array),
                                                 array_offset=array.offset)
                else:
                    raise Exception(
                        "Invalid variable type assignment during read operation for pidentifier {}".format(variable))
        else:
            raise Exception("Variable {} assignment during READ operation before declaration".format(variable))

    def handle_write(self, statement):
        """
        Handles translation of WRITE function call in code into assembly code.
        :param statement:
        :return: assembly code
        """
        from_var = statement.from_variable

        if isinstance(from_var, str):
            # If we're given a number
            value = self.get_value_of_assignee(from_var)
            return gen_write_const(value)

        elif isinstance(from_var, Int):
            # If we're given a variable to print
            pid = from_var.pidentifier
            index = self.get_mem_index(from_var)

            if self.is_updated_after_comp(from_var):
                return gen_write_var(index)
            else:
                # Get the value of var and handle it as constant
                value = self.get_value_of_assignee(from_var)
                return gen_write_const(value)

        elif isinstance(from_var, IntArrayElement):
            index_var = from_var.element
            var_array = self.get_object_from_mem(from_var.array_pid)

            if isinstance(index_var, str) or isinstance(index_var, Int) and not self.is_updated_after_comp(index_var):
                # Get the array index that we want to access
                index_value = self.get_value_of_assignee(index_var)

                # Calculate the index in memory of array(index_value)
                absolute_mem_index = index_value - var_array.offset + self.get_mem_index(var_array) + 1

                return gen_write_var(absolute_mem_index)

            elif isinstance(index_var, Int) and self.is_updated_after_comp(index_var):
                # Get the location in memory of the variable
                index_adress = self.get_mem_index(index_var)

                return gen_write_array_var(var_index=index_adress, array_index=self.get_mem_index(var_array),
                                           array_offset=var_array.offset)

    def update_generated_jump_indexes(self, translated_commands, pcval_before_translation):
        """
        WARNING: Doesn't work properly!
        Updates generated jump indexes in given translated commands list to new values
        :param pcval_before_translation: value of program counter before invoking translation
        :param translated_commands: list of translated commands in assembl code
        :return:
        """
        pc_offset = self.program_counter - pcval_before_translation
        offset_commands = []

        for command in translated_commands:
            comm = command.split()
            try:
                jump_index = int(comm.pop()) + pc_offset
                comm.append(str(jump_index))
                offset_commands.append(' '.join(comm))
            except ValueError:
                offset_commands.append(command)

        return offset_commands

    def return_condcheck_preparations(self, a, b):
        """
        Prepares necessary check-up of condition parameters in order to prepare code generation
        :param a:
        :param b:
        :param operand:
        :return:
        """
        a_arr_mem, a_arr_offset, b_arr_mem, b_arr_offset = None, None, None, None
        a_vid, b_vid = None, None

        if isinstance(a, str) or (isinstance(a, Int) and not self.is_updated_after_comp(a)):
            a_vid = self.get_value_of_assignee(a)

        elif isinstance(a, Int) and self.is_updated_after_comp(a):
            # If a's value is not known during compilation
            a_vid = self.get_mem_index(a)

        elif isinstance(a, IntArrayElement):
            a_array = self.get_object_from_mem(a.array_pid)
            a_arr_mem = self.get_mem_index(a_array)
            a_arr_offset = a_array.offset

            if isinstance(a.element, str):
                a_vid = self.get_value_of_assignee(a.element) - a_array.offset + self.get_mem_index(a_array) + 1

            elif isinstance(a.element, Int):
                a_vid = self.get_mem_index(a.element)

        if isinstance(b, str) or (isinstance(b, Int) and not self.is_updated_after_comp(b)):
            b_vid = self.get_value_of_assignee(b)

        elif isinstance(b, Int) and self.is_updated_after_comp(b):
            b_vid = self.get_mem_index(b)

        elif isinstance(b, IntArrayElement):
            b_array = self.get_object_from_mem(b.array_pid)
            b_arr_mem = self.get_mem_index(b_array)
            b_arr_offset = b_array.offset

            if isinstance(b.element, str):
                b_vid = self.get_value_of_assignee(b.element) - b_array.offset + self.get_mem_index(b_array) + 1

            elif isinstance(b.element, Int):
                b_vid = self.get_mem_index(b.element)

        return a_vid, b_vid, a_arr_mem, a_arr_offset, b_arr_mem, b_arr_offset

    def handle_if_statement(self, statement):
        """
        Handles translation of if and if-else statement into assembly code
        :param statement:
        :return:
        """
        a, compareop, b = statement.condition.return_condition()
        commands = statement.commands
        alt_commands = None

        if isinstance(statement, IfElse):
            # If dealing with if-else statement
            alt_commands = statement.alt_commands

        logging.debug("Handle if statement for condition: ({} {} {}), commands: {}".format(a, compareop, b, commands))

        if (isinstance(a, str) or (isinstance(a, Int) and not self.is_updated_after_comp(a))) \
                and (isinstance(b, str) or (isinstance(b, Int) and not self.is_updated_after_comp(b))):
            # If both a and b are numbers

            logging.debug("a: {}, b: {}".format(a, b))

            a_value = self.get_value_of_assignee(a)
            b_value = self.get_value_of_assignee(b)

            comparision_result = compareop(a_value, b_value)

            if comparision_result:
                # If condition is true, execute commands
                return self.translate_commands(commands)
            else:
                if isinstance(statement, IfElse):
                    # Execute alternative set of statements
                    return self.translate_commands(alt_commands)
                else:
                    # If condition is false, no commands will be executed
                    return []
        else:
            # Prepare values for code generation
            a_vid, b_vid, a_arr_mem, a_arr_offset, b_arr_mem, b_arr_offset = self.return_condcheck_preparations(a, b)

            # Translate contents of if statement (commands)
            translated_commands = self.delegate_translation(commands)
            if isinstance(statement, IfElse):
                # Include necessary jump to ELSE condition details
                translated_commands.append('JUMP X')

            # Generate resulting code of if statement
            result = gen_cond_statement(a_vid=a_vid, b_vid=b_vid, commands=translated_commands, compareop=compareop,
                                        pcval=self.program_counter,
                                        a_is_const=isinstance(a, str),
                                        b_is_const=isinstance(b, str),
                                        a_is_arrvar=isinstance(a, IntArrayElement),
                                        a_arr_mem=a_arr_mem, a_arr_offset=a_arr_offset,
                                        b_is_arrvar=isinstance(b, IntArrayElement),
                                        b_arr_mem=b_arr_mem,
                                        b_arr_offset=b_arr_offset)

            # Increment program counter
            self.program_counter += len(result)

            # Update program counter values in translated statement to correct ones
            result.extend(self.translate_commands(commands))

            if isinstance(statement, IfElse):
                # If normal part of statement is performed, add jump afterwards so that else is not performed
                alt_commands_translated = self.delegate_translation(alt_commands)

                self.program_counter += 1
                result.append('JUMP {}'.format(len(alt_commands_translated) + 1))
                result.extend(self.translate_commands(alt_commands))

            return result

    def handle_while_statement(self, statement):
        """
        Prepares the translation of while/do-while statement code
        :param statement:
        :return:
        """
        # TODO: Add known values condition handler just like for if statement
        a, compareop, b = statement.condition.return_condition()
        commands = statement.commands

        logging.debug("Handle while statement for condition: ({} {} {}), commands: {}".format(a, compareop, b,
                                                                                              commands))

        # Prepare values for code generation
        a_vid, b_vid, a_arr_mem, a_arr_offset, b_arr_mem, b_arr_offset = self.return_condcheck_preparations(a, b)

        # Translate contents of if while statement (commands)
        translated_commands = self.delegate_translation(commands)
        translated_commands.append('JUMP X')

        # Generate resulting code of if statement
        result = gen_cond_statement(a_vid=a_vid, b_vid=b_vid, commands=translated_commands,
                                    compareop=compareop,
                                    pcval=self.program_counter,
                                    a_is_const=isinstance(a, str),
                                    b_is_const=isinstance(b, str),
                                    a_is_arrvar=isinstance(a, IntArrayElement),
                                    a_arr_mem=a_arr_mem, a_arr_offset=a_arr_offset,
                                    b_is_arrvar=isinstance(b, IntArrayElement),
                                    b_arr_mem=b_arr_mem,
                                    b_arr_offset=b_arr_offset)

        # Increment program counter
        jump_to = self.program_counter
        self.program_counter += len(result)

        # Update program counter values in translated statement to correct ones
        result.extend(self.translate_commands(commands))

        # Add jump after commands so that condition check will be performed (and while loop will work)
        result.append('JUMP {} # WHILE_LOOP_COND_CHECK'.format(jump_to))
        return result

    def handle_do_while_statement(self, statement):
        """
        Prepares the translation of do-while condition flow statement
        :param statement:
        :return:
        """
        # TODO: Add known values condition handler just like for if statement
        a, compareop, b = statement.condition.return_condition()
        commands = statement.commands

        logging.debug("Handle do-while statement for condition: ({} {} {}), commands: {}".format(a, compareop, b,
                                                                                                 commands))

        # Prepare values for code generation
        a_vid, b_vid, a_arr_mem, a_arr_offset, b_arr_mem, b_arr_offset = self.return_condcheck_preparations(a, b)

        # Translate contents of if while statement (commands)
        translated_commands = self.delegate_translation(commands)
        translated_commands.append('JUMP X')
        translated_commands.append('JUMP X')

        # Generate condition statement
        cond_statement = gen_cond_statement(a_vid=a_vid, b_vid=b_vid, commands=translated_commands,
                                            compareop=compareop,
                                            pcval=self.program_counter,
                                            a_is_const=isinstance(a, str),
                                            b_is_const=isinstance(b, str),
                                            a_is_arrvar=isinstance(a, IntArrayElement),
                                            a_arr_mem=a_arr_mem, a_arr_offset=a_arr_offset,
                                            b_is_arrvar=isinstance(b, IntArrayElement),
                                            b_arr_mem=b_arr_mem,
                                            b_arr_offset=b_arr_offset)

        # Omit first condition check
        result = []

        # Omit first condition check
        # Add jump condition to jump to code execution first
        result.append('JUMP {} # DO_WHILE_OMIT_FIRST_CHECK'.format(self.program_counter + len(cond_statement) + 1))
        result.extend(cond_statement)

        # Increment program counter
        jump_to = self.program_counter + 1
        self.program_counter += len(cond_statement)

        # Update program counter values in translated statement to correct ones
        result.extend(self.translate_commands(commands))

        # Add jump after commands so that condition check will be performed (and do-while loop will work)
        result.append('JUMP {} # DO_WHILE_COND_CHECK'.format(jump_to))
        return result

    def handle_for_statement(self, statement):
        # TODO: Add known values condition handler just like for if statement
        """
        Prepares the translation of for loop statement code
        :param statement:
        :return:
        """
        pid = statement.pidentifier.pidentifier  # Variable pidentifier
        from_val = statement.from_val  # Starting value
        to_val = statement.to_val  # Ending value ( <= )
        commands = statement.commands

        # Perform iterator check in global_vars
        if pid not in self.global_vars.keys():
            iterator = Int(pidentifier=pid, lineno=None)
            iterator.set_as_iterator()

            self.global_vars[pid] = Int(pidentifier=pid, lineno=None)
            self.var_index[pid] = self.next_free_mem_index
            self.next_free_mem_index += 1
        elif pid in self.global_vars.keys():
            iter_candidate = self.get_object_from_mem(pid)

            if not iter_candidate.is_iterator:
                raise Exception("Iterator pidentifier '{}' already declared".format(pid))

        logging.debug("global_vars after update: {}, mem_indexes: {}".format(self.global_vars, self.var_index))
        logging.debug("Handle for loop from {} := {} to {}, commands: {}".format(pid, from_val, to_val, commands))

        # Get index of iterator in memory
        iterator_mem_index = self.get_mem_index_for_pid(pid)

        # Translate contents of if while statement (commands)
        translated_commands = self.delegate_translation(commands)
        # translated_commands.append('INC X')
        translated_commands.append('INC F')
        translated_commands.extend(gen_storeval(var_mem_index=self.get_mem_index(self.global_vars[pid]),
                                                from_registry='F'))
        translated_commands.append('JUMP X')

        # Handle different variable cases
        # a_vid, b_vid, a_arr_mem, a_arr_offset, b_arr_mem, b_arr_offset = self.return_condcheck_preparations(from_val,
        #                                                                                                     to_val)

        # Generate resulting code of if statement
        result, begin_jump = gen_for_loop(iter_mem_index=iterator_mem_index, from_value=from_val, to_value=to_val,
                                          compareop=operator.le, commands=translated_commands,
                                          pcval=self.program_counter)

        # Increment program counter
        self.program_counter += len(result)

        # Update program counter values in translated statement to correct ones
        result.extend(self.translate_commands(commands))

        # Add jump after commands so that condition check will be performed (and while loop will work)
        result.append('INC F # FOR_LOOP_ITER++')
        result.extend(gen_storeval(var_mem_index=iterator_mem_index, from_registry='F'))
        result.append('JUMP {} # FOR_LOOP_COND_CHECK'.format(begin_jump))
        return result

    def handle_for_downto_statement(self, statement):
        # TODO: Add known values condition handler just like for if statement
        """
        Prepares the translation of for loop statement code
        :param statement:
        :return:
        """

        pid = statement.pidentifier.pidentifier  # Variable pidentifier
        from_val = int(statement.from_val)  # Starting value
        to_val = int(statement.to_val)  # Ending value ( <= )
        commands = statement.commands

        # TODO: WARNING!!!
        # HANDLE CASE WHEN FROM_VAL, TO VAL IS PASSED VARIABLE!!!!!!!!!!!!!!

        logging.debug("!!!! FROM VAL: {} !!!!! TO_VAL: {} !!!!!".format(from_val, to_val))

        # Perform iterator check in global_vars
        if pid not in self.global_vars.keys():
            iterator = Int(pidentifier=pid, lineno=None)
            iterator.set_as_iterator()

            self.global_vars[pid] = Int(pidentifier=pid, lineno=None)
            self.var_index[pid] = self.next_free_mem_index
            self.next_free_mem_index += 1
        elif pid in self.global_vars.keys():
            iter_candidate = self.get_object_from_mem(pid)

            if not iter_candidate.is_iterator:
                raise Exception("Iterator pidentifier '{}' already declared".format(pid))

        logging.debug("global_vars after update: {}, mem_indexes: {}".format(self.global_vars, self.var_index))
        logging.debug("Handle for loop from {} := {} to {}, commands: {}".format(pid, from_val, to_val, commands))

        # Get index of iterator in memory
        iterator_mem_index = self.get_mem_index_for_pid(pid)

        # Translate contents of if while statement (commands)
        translated_commands = self.delegate_translation(commands)
        # translated_commands.append('INC X')
        translated_commands.extend(gen_getval(var_mem_index=iterator_mem_index, to_registry='F'))
        translated_commands.append('DEC F')
        translated_commands.extend(gen_storeval(var_mem_index=self.get_mem_index(self.global_vars[pid]),
                                                from_registry='F'))
        translated_commands.append('JUMP X')

        # Generate resulting code of if statement
        result, begin_jump = gen_fordownto_loop(iter_mem_index=iterator_mem_index, from_value=from_val, to_value=to_val,
                                                compareop=operator.le, commands=translated_commands,
                                                pcval=self.program_counter)

        # Increment program counter
        self.program_counter += len(result)

        # Update program counter values in translated statement to correct ones
        result.extend(self.translate_commands(commands))

        # Add jump after commands so that condition check will be performed (and while loop will work)
        result.extend(gen_getval(var_mem_index=iterator_mem_index, to_registry='F'))
        result.append('DEC F # FOR_LOOP_ITER++')
        result.extend(gen_storeval(var_mem_index=iterator_mem_index, from_registry='F'))
        result.append('JUMP {} # FOR_LOOP_COND_CHECK'.format(begin_jump))
        return result

    def delegate_translation(self, commands):
        """
        Returns translated commands without performing additional operations
        (program counter incrementations, etc.)
        :param commands: list of commands
        :return: assembly code
        """
        code = []

        for command in commands:
            if isinstance(command, Assign):
                translated_code = self.handle_assignment(command)

            elif isinstance(command, Write):
                translated_code = self.handle_write(command)

            elif isinstance(command, Read):
                translated_code = self.handle_read(command)

            elif isinstance(command, If):
                translated_code = self.handle_if_statement(command)

            elif isinstance(command, While):
                translated_code = self.handle_while_statement(command)

            elif isinstance(command, DoWhile):
                translated_code = self.handle_do_while_statement(command)

            elif isinstance(command, ForDownTo):
                translated_code = self.handle_for_downto_statement(command)

            elif isinstance(command, For):
                translated_code = self.handle_for_statement(command)

            else:
                raise Exception("Unsupported command given for translation: {}".format(command))

            code.extend(translated_code)

        return code

    def translate_commands(self, commands):
        """
        Translates given commands into assembly code
        :param commands: list of commands
        :return: assembly code
        """
        code = []

        for command in commands:
            if isinstance(command, Assign):
                translated_code = self.handle_assignment(command)

            elif isinstance(command, Write):
                translated_code = self.handle_write(command)

            elif isinstance(command, Read):
                translated_code = self.handle_read(command)

            elif isinstance(command, If):
                translated_code = self.handle_if_statement(command)

            elif isinstance(command, While):
                translated_code = self.handle_while_statement(command)

            elif isinstance(command, DoWhile):
                translated_code = self.handle_do_while_statement(command)

            elif isinstance(command, ForDownTo):
                translated_code = self.handle_for_downto_statement(command)

            elif isinstance(command, For):
                translated_code = self.handle_for_statement(command)

            else:
                raise Exception("Unsupported command given for translation: {}".format(command))

            self.program_counter += len(translated_code)
            code.extend(translated_code)

        return code

    def make(self):
        """
        Goes through generated tree and calls method responsible for given blocks' translations.
        :return: self
        """
        # print("Code tree: {}".format(self.tree))

        logging.basicConfig(level=logging.DEBUG)

        # Divide the program into header (declarations) and code
        header = self.tree[0]
        body = self.tree[1]

        logging.debug("Code header: {}".format(header))
        logging.debug("Code body: {}".format(body))

        print(body)

        self.alloc_global_vars(header)
        logging.debug("Global variables: {}".format(self.global_vars))
        logging.debug("Assigned indexes: {}".format(self.var_index))

        # print("Identifier: {}".format(body[0].identifier))
        # print("Expression value: {}".format(body[0].expression.return_expression()))
        # print("Expression array element: {}".format(body[0].expression.return_expression()[0].element))

        output = self.translate_commands(body)
        output.append('HALT')

        print(output)

        outf = open('tests/program4.out', 'w').write('\n'.join(output))
